//js engines
first JavaScript engines were mere interpreters, but all relevant modern engines utilize just-in-time compilation for improved performance
The use of JavaScript engines is not limited to browsers. For example, the Chrome V8 engine is a core component of the popular Node.js runtime system
firefox - mozilla - spider monkey(netscape navigator)
google - chrome - V8
apple - safari - nitro
microsoft - IE -  chakra | edge - V8
Browsers have added support for WebAssembly - 4th language browsers can understand apart from html,css and js
layout engine or rendering engine: ransform HTML and css to a visual representation
gecko - mozilla
webkit - apple
chrome - blink
edge - blink


//functional programming
1)Pure functions instead of shared state & side effects- same output for same input all the times
2)Function composition
3)Immutability is a central concept of functional programming
An immutable object is an object that can’t be modified after it’s created
4)FP concepts - HOC(for reusability instead of polymorphism), function composition(instead of inheritance)
closures instead of encapsulation, currying
5)Declarative rather than imperative code (what to do, rather than how to do it)
6)In functional programming things are loosely coupled but in OO things are tightly coupled.


//javascript imp stuff
*JavaScript is a high-level, dynamic, untyped, and interpreted programming language.
*examples of low-level languages are assembly and machine code -  machine-dependent and non-portable - It needs assembler for translation
*high level languages are C, C++, Java, Python,js - needs compiler or interpreter for translation
*JavaScript is a multi-paradigm language, supporting functional and object oriented (prototypal inheritance) - 2 pillars of js
*First-class functions - function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable
*FP - avoids shared state & mutable data, first-class functions, higher order functions, function composition, Pure functions,Avoid side-effects
*OOP - tightly coupled, shared state, different things competing for the same resources(race condition)

//currying - functional programming concept is the idea of currying or partially applying argument values to a function
var curriedAdd = function(a) {
    return function(b) {
        return a + b;
    };
};
var addTen = curriedAdd(10);
addTen(10); //20

By currying and composing your functions u r creating a pipeline for data processing.

//This in js - call, apply and bind to the rescue
As a DOM event handler - set to the element on which the listener is placed //this === e.currentTarget
As a constructor - this is bound to the new object being constructed.
object method - this is set to the object the method is called on.
arrow function - this is permanently bound to the this of its enclosing function.
global execution context (outside of any function), this refers to the global object whether in strict mode or not.
random function - this refers to window and undefined in strict mode
function f2() {
  'use strict'; // see strict mode
  return this;
}
f2() === undefined; // true

var o = {
  prop: 37,
  f: function() {
    return this.prop;
  }
};
console.log(o.f()); // 37

var o = {prop: 37};
function independent() {
  return this.prop;
}
o.f = independent;
console.log(o.f()); // 37

var o = {f: function() { return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5

var obj = {
  bar: function() {
    var x = (() => this);
    return x;
  }
};
var fn = obj.bar();
console.log(fn() === obj); // true
var fn2 = obj.bar;
console.log(fn2()() == window); 

function f() {
  return this.a;
}
var g = f.bind({a: 'azerty'});
console.log(g()); // azerty
var h = g.bind({a: 'yoo'}); // bind only works once!
console.log(h()); // azerty