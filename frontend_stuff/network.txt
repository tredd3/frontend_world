
//http vs https
HTTP provides standard rules for web browsers & servers to communicate.
HTTP is an application layer network protocol which is built on top of TCP.
HTTPS: It is a combination of SSL/TLS protocol and HTTP. 
Transport Layer Security/Secure Sockets Layer, are cryptographic protocols designed to provide communications security over a computer network
https://www.guru99.com/difference-http-vs-https.html
https://developer.mozilla.org/en-US/docs/Web/HTTP


https://www.youtube.com/watch?v=vv4y_uOneC0
//Open System Interconnection Model | OSI 7 layers
how data is transferred from one computer to another
A - application layer - 
P - presentaion - 
S - session - 
T - transport - 
N - network - 
D - data link - 
P - physical - 


//Network Requests
ASCII characters - Codes 0 through 127 (all keyboard chars)
NON ASCII characters - Codes 128 through 255
x-www-form-urlencoded - to send simple text/ ASCII data
form-data - to send non-ASCII text or blob data like files and image uploading
Raw - if you want to send plain text /JSON/XML
Binary - non-textual data to the request, e.g. a video/audio file, images, or any other binary data file

REST Architecture - JSON ,CACHING, LESS BANDWIDTH,
API - programs built on different platforms and programming languages could exchange data in an easy manner.


// SERVER INTERACTION
By default,�HTTP�uses�port�80 and HTTPS uses�port�443
AJAX  uses XHR object and AJAX is used for partial page updates without full refresh.
AJAX - the process establishing a connection, sending request to server , getting the response and then updating the DOM
Fetch API - �Fetch API uses Promises, which enables a simpler and cleaner API, avoiding callback hell
API�stands for Application Programming Interface. It makes it possible to transfer data from an application to other applications.
REST APIs�uses multiple standards like HTTP, JSON, URL, and XML while SOAP�APIs�is largely based on HTTP and XML


//encoding vs encryption vs compression
*Encoding - Encoding is for maintaining data usability and can be reversed by employing the same algorithm that encoded the content, i.e. no key is used
used for reducing the size of audio and video files
Example: ASCII, BASE64, gzip 
*Encryption - maintaining data confidentiality and requires the use of a key (kept secret) to read it
*Compression - reduce the size of the data representation (gzip)
what is ASCII?  American Standard Code for Information Interchange, is a character encoding standard
The ASCII table has 128 characters, with values from 0 through 127.
 Thus, 7 bits are sufficient to represent a character in ASCII; however, most computers typically reserve 1 byte, (8 bits), for an ASCII character.
**What is Base 64 Encoded Data? each char represented by 6 bits
base64 encoded data is a string of character that contains only a-z, A-Z, 0-9, + and / characters and is often used in situations when sending non-text information via a text only transmission protocol.
The plain ASCII text includes a-z, A-Z, 0-9, ", %, &, ', (, ), *, +, -, _ and , (the comma). They will be referred to as the universal ASCII character set.
when trying to send e-mails in non English languages. Often these languages will have characters that are not part of the ASCII set.
 What is needed is a method to convert non-universal ASCII characters to a common form. This common form is called Base64 encoding.
**What does Base 64 Encoding Do?
Base 64 Encoding takes a stream of characters and converts them to characters that belong to the universal ASCII character set. 
Once a stream of characters has been converted to characters that belong to the universal ASCII character set (Base 64 encoded) 
they can be transported with ease over the Internet using the e-mail protocols.


********* HTTP ***********
//overview 
*application-layer protocol  for communication between web browsers and web servers,
application layer protocol that is sent over TCP, or over a TLS-encrypted TCP connection
*HTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests
*Between the Web browser and the server, numerous computers and machines like proxies, modem and routers
*HTTP is simple(human readable messages), extensible(simple agreement between a client and a server about a new header's semantics),
stateless, but not sessionless - there is no link between two requests being successively carried out on the same connection.
HTTP cookies allow the use of stateful sessions
*Though HTTP doesn't require the underlying transport protocol to be connection-based; only requiring it to be reliable, or not lose messages
TCP is reliable and UDP isn't. HTTP therefore relies on the TCP standard, which is connection-based
*HTTP flow: Open a TCP connection, Send an HTTP message, Read the response sent by the server, Close or reuse the connection for further requests
*both XHR and Fetch API are based on HTTP
*headers convey additional information to browsers/servers.
*features controllable with HTTP: caching, origin constraint, Authentication(authentication header and cookie),
sessions(cookies),Proxy and tunneling, compression


//HTTP Headers


//HTTP Request Methods

//HTTP status Codes
200 - success
301 - moved permanently
304 - not modified
4** - client error
400 - bad request
401 - unauthorised (not autheniticated)
403 - forbidden (unauthorised)
404 - not found
5** - server error
500 - Internal Server Error
501 - Not Implemented
502 - Bad Gateway
504 - Gateway Timeout

//Evolution of HTTP
**HTTP/1.1
currently browsers open up to 6 parallel connections under HTTP/1.1
open a separate TCP connection for each HTTP request/response pair

**HTTP/2
HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, allowing optimizations like compression of headers and multiplexing.
HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm and more efficient
multiplexing allows your Browser to fire off multiple requests at once on the same connection and receive the responses back in any order

//HTTP caching - only GET requests
Private browser caches - specific to a user browser (preferred)
Shared proxy caches - popular resources are reused a number of times
Cache-Control: no-store //No caching
Cache-Control: no-cache //Cache but revalidate
pragma same as Cache-Control: no-cache, if the Cache-Control header field is omitted in a request. Use Pragma only for backwards compatibility with HTTP/1.0 clients
Cache-Control: public //response may be cached by any cache
Cache-Control: private //intended for a single user only and must not be stored by a shared cache
Cache-Control: max-age=31536000 //expiration
Cache-Control: must-revalidate //must verify the status of the stale resources before using it and expired ones should not be used
**freshness of cache
Cache-Control: "max-age=<seconds>"(relative to the time of the request) and EXPIRES header (random date and time)
cache validation - when the cache receives a request for a stale resource
it forwards this request with a If-None-Match request header and Etag response header with hash value
If-Modified-Since request header and Last-Modified response header
to check if it is in fact still fresh. If so, the server returns a 304 (Not Modified) header without sending the body of the requested resource, saving some bandwidth.
if neither header is present, look for a Last-Modified header
** serving content dynamically
When using the Vary: User-Agent header, caching servers should consider the user agent when deciding whether to serve the page from cache.
Because the User-Agent header value is different ("varies") for mobile and desktop clients, 
caches will not be used to serve mobile content mistakenly to desktop users or vice versa.


//HTTP Authentication


//FETCH API
1)fetch() allows you to make network requests similar to XMLHttpRequest (XHR) but Fetch API uses Promises, avoiding callback hell 
The response of a fetch() request is a Stream object, use the json() method to convert it into json
2)Timeouts Are Not Supported - request will continue for as long as the browser chooses.
function fetchTimeout(url, init, timeout = 3000) {
  return new Promise((resolve, reject) => {
    fetch(url, init)
      .then(resolve)
      .catch(reject);
    setTimeout(reject, timeout);
  }
}
Promise.race([
  fetch('http://url', { method: 'GET' }),
  new Promise(resolve => setTimeout(resolve, 3000))
])
3)cookies byfault don't go in a fetch request unlike XHR
4)Surprisingly, an HTTP error such as a 404 Page Not Found or 500 Internal Server Error does
 not cause the Fetch Promise to reject
5)abort the fetch request 
const controller = new AbortController();
Fetch can be aborted by calling controller.abort();
6)IE doesn't suppor fetch it needs a polyfill
**fetch modes
1)same-origin only succeeds for requests for assets on the same origin, all other requests will reject.
2)cors will allow requests for assets on the same-origin and other origins which return the appropriate CORs headers.
cors response restricts the headers you can view to `Cache-Control`, `Content-Language`, `Content-Type`, `Expires`, `Last-Modified`, and `Pragma`.
3)cors-with-forced-preflight will always perform a preflight check before making the actual request.
4)no-cors is intended to make requests to other origins that do not have CORS headers and result in an opaque response(u can't view),
 but as stated, this isn't possible in the window global scope at the moment but servie workers suopport


//Cross-Origin Resource Sharing (CORS)
In CORS, a preflight request with the OPTIONS method is sent, so that the server can respond whether it
 is safe to send the request with these parameters or is the server ready to accept the request at this point
Access-Control-Request-Method header notifies the server as part of a preflight request that when the 
actual request is sent, it will be sent with a POST request method. The Access-Control-Request-Headers
The server responds with Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers
Access-Control-Max-Age gives the value in seconds for how long the response to the preflight request can be cached for without sending another preflight request


//JSONP stands for JSON with Padding
Requesting a file from another domain using XHR can cause problems, due to cross-domain policy. 
Requesting an external script from another domain does not have this problem.
JSONP uses this advantage, and request files using the script tag instead of the XHR object.


//IFRAME
An inline frame is used to embed another document within the current HTML document.
like embedding a google map and youtube video
iframe to main window communication is via post message
