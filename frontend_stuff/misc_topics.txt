
//ADVANCED2

https://blog.pramp.com/how-to-succeed-in-a-frontend-interview-d748cb073823
https://codeburst.io/de-coding-the-front-end-development-interview-process-9601bc4c71e5
https://medium.com/capital-one-tech/why-everyone-is-talking-about-isomorphic-universal-javascript-and-why-it-matters-38c07c87905
https://medium.com/@yej.arin.choi/this-is-a-post-that-summarizes-my-dive-into-immutability-in-programming-what-it-is-why-its-34cbba44f889
https://developers.google.com/web/progressive-web-apps/
https://2ality.com/2015/01/es6-maps-sets.html


//push notifications�can appear anytime, in-app notifications�only appear while someone is using the�app
//An iframe is used to display a web page within a web page.

//React(Library ) vs React native(Framework for building native hybrid apps using JavaScript)
React Native is a complete platform, similar to a web browser, and  it provides a lot of the same APIs (e.g. XMLHttpRequest, setTimeout, geolocation, etc) -uses native components instead of web components -  u can�t use browser features(it has it�s own API)
ReactJS is used for UI layer- u can use browser features - u can use it for websites and apps.
React Native framework uses ReactJS library. it is also possible to use React Native in the browser by using react-native-web
Both PhoneGap and  React Native  are �bridge� between JS and native platform
 Cordova, PhoneGap for hybrid apps - render code via WebView so u can use angular and other web technologies unlike React Native where u can only use React. Same ui only all platforms and u can code once run anywhere .You can still access phone components via the navigator API. Sluggish performance
React Native for native apps - renders native components.The app feels & looks native (different ui on different platforms) hence some components needed to be coded specific to platform. Better user experience and zero compromises on performance
One single code base for both android and IOS both incase of webview + phonegap and react-native. But, incase of react native u will get native app feel.
react-native-web: This library will convert our react-native components into web elements
react-router-native:�routing library for React Native 
react-router-dom:�routing library for React on the web 
React uses HTML,CSS, virtual Dom  but React Native doesn't. we have to use native syntax,  animated API for css and Native API�s to render components on mobile.
Server side rendering - faster initial Loading  and SEO improvement  
isomorphic application�is one whose code (in this case, JavaScript) can run both in the server and the client.
Do you need to make a highly complex app which utilizes a large portion of platform-specific code?�Go native.
Does your app need to support new mobile OS features as soon as they are released?�Go native.


//SEO - process of increasing website traffic by putting ur site on the top web search engine results
*extremely imp for business to convert visitors to customers
*Cloaking - content given to browsers is diff from that given to search crawlers
let's say the page is full of videos and the user is searching for the content present in he video.
now the search engines cannot go and search inside the video. so we need to put the content into a separate file so that web crawlers can read it
*progressive enhancement: allows everyone to access the basic content and functionality of a web page, using any browser or Internet connection, 
while also providing an enhanced version of the page to those with more advanced browser software or greater
*header and semantic tags
*leverage meta tags by adding the content - must for SPA's as the content is generated only on the 
client side and crawler has no content to search on 
*server side rendering

//currying - splitting up a function that takes multiple arguments (params) into a sequence of functions that each take an individual argument.
const sum = function(a) {
  return function(b) {
    return a + b
  }
}
sum(3)(4)
// no curry
const sum = (a, b) => a + b

// curry
const sum = a => b => a + b

Static assets: Assets which you don�t create  dynamically with server-side code. e.g: html, js, css, images etc

https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers

Service worker: proxy server , which intercepts your network request 
served over HTTPS so we know the service worker the browser receives hasn't been tampered with during its journey through the network.
It is specific to origin . Multiple js files in an origin can use the data/service provided by the service worker.
It is event driven and It is designed to be fully async hence it uses promises heavily .
it's a replacement for APP cache and covers all it's loop holes.
A service worker is run in a worker context: it therefore has no DOM access, and runs on a different thread different from the main JavaScript thread, so it is not blocking. 
 it can't access the DOM directly. Instead, a service worker can communicate with the pages it controls by responding to messages sent via the postMessage interface, and those pages can manipulate the DOM if needed.
Cache storage API- Provides a master directory of all the named caches that can be accessed by a ServiceWorker
used for caching static assets, network requests
Service workers are also intended to be used for such things as:
* Background data Synchronization(web to server and vice versa) Start up a service worker even when no users are at the site, so caches can be updated,
* Responding to resource requests from other origins.
* Receiving Centralized updates to expensive-to-calculate data such as geolocation or gyroscope, so multiple pages can make use of one set of data.
* Push notifications handling
* offline experiences (by serving files from cache)
* Performance enhancements, for example pre-fetching resources that the user is likely to need in the near future, such as the next few pictures in a photo album
* service workers will be able to do a number of other useful things for the web platform that will bring it closer towards native app viability.
//Updating your service worker
If your service worker has previously been installed, but then a new version of the worker is available on refresh or page load, 
the new version is installed in the background, but not yet activated. It is only activated when there are no longer any pages 
loaded that are still using the old service worker. As soon as there are no more such pages still loaded, the new service worker activates.
//It's terminated when not in use, and restarted when it's next needed. If there is information that you need to persist and reuse across restarts, service workers do have access to the IndexedDB API.


memoization or Memoisation is an Optimization technique used primarily to speed up computer programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again.
Immutable.js�is a data structure library built by Facebook to work with React � and it uses Structural Sharing(reduces time and space in copying nested data structures)
Numbers ,strings are are also immutable structures�
Let x=4
Let y=x (value is copied)
x=8
//y=4
//x=8
Array, object, function, class, maps, sets are mutable 
Let u ={d:8,k:9}
Let v=u (v references  u but the object is not copied )

Why immutable.js???
If you use Immutability, you are always creating a copy of the old data structure and applying the changes to the copy instead of changing the original data structure!
In Redux we do the same thing. But if you had multiple nested levels of objects/arrays then immutable.js comes to help
1)Easier to Debug : immutability stresses removing all side-effects and using�pure functions
2)Easier Deep Value Comparisons: you can just compare the memory locations of the data structures to see if their values are the same or not (instead of having to traverse deeply into the data structure)
3)easier to manage concurrency (without locks or snapshots)
Immutable.fromJS()method converts any nested object/array into Immutable Map/List

Isomorphism - rendering pages on both the server and client side. It usually implies the use of JavaScript and Node.js/Io.js because they allow for the re-use of libraries.
Whenever you visit a website, your browser makes a request to the server that contains the contents of the website.�The request depends on multiple factors
* 		Your internet speed
* 		the location of the server
* 		how many users are trying to access the site
* 		and how optimized the website is, to name a few
isomorphism address the issues of SEO, performance, and maintainability

Server side rendering pros:
* Search engines can crawl the site for better SEO as the content is already present.
* The initial page load is faster and aft
* Great for static sites.
* Used for campaigns and marketting as the content is controllable from server
Server-side cons:
* Frequent server requests.
* Full page reloads.
* Non-rich site interactions.

Client-side pros:
* get the skeleton from server and dynamically render content using react/ js
* Fast website rendering after the initial load.

Client-side cons:
* Low SEO if not implemented correctly. (Use metatags)
* Initial load might require more time bcoz of use of  an external library.


