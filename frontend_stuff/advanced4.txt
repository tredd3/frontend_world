
//ADVANCED4
Responsive web design - Screen sizes are always changing, so it's important that your site can adapt to any screen size. 
Layout changes based on screen size
Requirements: meta viewport tag, media-queries, mobile first approach
Aspect ratio - the ratio of the width to the height of an image or screen. Landscape - Aspect ratio >1, portrait - Aspect ratio <1
Use css media queries for �rendering the content based on  the display type, width, height, orientation, and even resolution.
Create breakpoints based on content, never on specific devices 
* Use relative sizes for images/content to prevent them from accidentally overflowing the container

//�CSS unit types
1vw is 1% of the width of the viewport.�
1vh is 1% of the height of the viewport.�
1em/1rem = 16px is on the top element. After that 1 em = font size of the nearest parent  and 1 rem = font size of the html element

3 types of pixels:
Css pixels - these change in size with the viewport size . For e.g when we zoom
Density independent pixels(DIPs) - 
Device pixels - fixed hardware fixes

// Images
There are two types of images to consider:�vector images�and�raster images. For raster images, you also need to choose the right compression format, for example:�GIF,�PNG,�JPG
vector images� can be scaled without any loss in quality or change in file size.
Include image Optimization and compression tools into your workflow to reduce file sizes
reduce the number of http requests by placing frequently used images into image sprites
Lazy loading - I.e loading the images when they appear on viewport till then use a placeholder image of equal size

// SERVER INTERACTION
By default,�HTTP�uses�port�80 and HTTPS uses�port�443
AJAX  uses XHR object and AJAX is used for partial page updates without full refresh.
AJAX - the process establishing a connection, sending request to server , getting the response and then updating the DOM
Fetch API - �Fetch API uses Promises, which enables a simpler and cleaner API, avoiding callback hell
API�stands for Application Programming Interface. It makes it possible to transfer data from an application to other applications.
REST APIs�uses multiple standards like HTTP, JSON, URL, and XML while SOAP�APIs�is largely based on HTTP and XML

// SESSION MANAGEMENT
https://medium.com/lightrail/getting-token-authentication-right-in-a-stateless-single-page-application-57d0c6474e3
https://stormpath.com/blog/token-auth-spa
https://www.appfoundry.be/blog/2018/11/24/session-management-in-react-single-page-applications/
Traditionally using cookies but ur app is vulnerable to XSS and CSRF attacks.
Also Cookies are primarily designed for web browsers and not for other types of clients such as native mobile applications or desktop programs.
Other limitations�are size of the cookie and access to user to for disabling, modifying or erasing them.

Token based authentication - send ur credentials to authorisation server get the token , use the token to get the resource from resources server

//JWT -https://jwt.io/introduction/
https://logrocket.com/blog/jwt-authentication-best-practices/
JSON Web Token - JWT is created by authentication server and given to user.  JWT shouldn�t be stored in cookies.
For signed tokens payload information, though protected against tampering, is readable by anyone. Do not put secret information in the payload or header elements of a JWT unless it is encrypted.
Single Sign On feature widely uses JWT. U can also use JWT for securely transmitting information between parties (as the content will not be tampered and the sender is identified)
Single sign-on�(SSO) is a session and user authentication service that permits an end user to enter one set of login credentials (such as a name and password) and be able to access multiple applications.
JSON Web Tokens consist of three parts separated by dots (.), which are:
* Header - JSON - {
  "alg": "HS256",
  "typ": "JWT"
}
* Payload - JSON-  {
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
* Signature  - HMACSHA256 (base64UrlEncode(header) + �.� +base64UrlEncode(payload),secret). Secret can be anything that is decided by developers 
Because JWTs can be signed you can be sure the senders are who they say they are.�
As the signature is calculated using the header and the payload, you can also verify that the content hasn't been tampered with.

Therefore, a JWT typically looks like the following.
xxxxx.yyyyy.zzzzz


$.ajax({
  url: URL,
  method: "GET",
  headers: {
    "Authorization":
      "Bearer JWT token returned by server�,
  },
}).then(function(response) {
  console.log(response);
}).catch(function(err) {
  console.error(err);
});