//ADVANCED1 

What’s the problem with MVW frameworks? How redux solves the problem
https://blog.gisspan.com/2017/02/Redux-Vs-MVC,-Why-and-How.html
//Problem with MVC
 MVC becomes  a headache  when an application grows in size as it is difficult to  manage multiple controllers and models and their interactions -  REDUX solution centralised store and only single way of modifying it
We lose control of who changed the state of a controller and why they changed it -  REDUX solution suing actions to modify state and as they are JS objects we can log them
In MVC we mutate the model hence No way to do undo (travel back in time) easily - REDUX solution no mutation
When to consider the state or model is changed and how to build tools to help recognize the mutation - REDUX solution  dispatch  action and subscribe to changes

//REDUX - strict unidirectional data flow Architecture for building complex and scalable Apps (caching, PWA, server state sync, offline support etc)
3 core principles
1.Single source of truth - The whole application state is stored in an object tree inside a single store.  // react components have their own component state
2.State is read-only - The only way to change the state tree is to emit an action, an object describing what happened.
Actions are the only source of information for the store. You send them to the store using store.dispatch()
To specify how the actions transform the state tree, you write pure reducers.
Actions can be triggered by user interaction/events , network request and on routing
Reducers are just pure functions that take the previous state and an action, and return the next state without mutating the state
//Things you should never do inside a reducer:
 Mutate its arguments;
 Perform side effects like API calls and routing transitions; (where to do it??)
 Call non-pure functions, e.g. Date.now() or Math.random()
each reducer manages its own part of the global state. The state parameter is different for every reducer, and corresponds to the part of the state it manages.
actions are processed by reducers synchronously.
Store
// each reducer returns a object and all the objects are merged to form a big object called store
// In the application state object each key is the reducer function name (it can be different as well)and value is the partial state returned by a reducer function
// partial state can be any data type not necessarily object
//keep your state as normalized as possible, without any nesting . if there is a nesting involved use immutable.js for performance
//once u dispatch an action to the store all the reducers are called and  based on the action type one/multiple reducers changes the  application state
//subscribers are only notified only once per dispatch action. i.e when all the reducers are done changing the state of the application by a single action
//Redux’s store has one method called dispatch and it has another method to subscribe to state changes called subscribe . But we can use  view binding library like react-redux
 React-redux generates container components using connect function .These components are connected/subscribed to the Redux store.  
Technically, a container component is just a React component that uses store.subscribe() to read a part of the Redux state tree and supply props to a presentational component it renders
you could write the container components by hand using store.subscribe(). We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand.
We can use batch function  to ensure that multiple actions dispatched outside of React only result in a single render update
middleware - for async actions
Synchronous actions - when we dispatch action(object) the state gets updated immediately
async actions - when we dispatch action(function) the state gets updated after sometime
an action creator(called thunk) can return a function /promise instead of an action object and that function/promise  will get executed by the Redux Thunk middleware. 
This function doesn't need to be pure. It is allowed to have side effects, including executing asynchronous API calls/routing etc. The function can also dispatch actions
Any middleware you use can then intercept anything you dispatch, and in turn, can pass actions to the next middleware in the chain. 
When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the synchronous Redux data flow takes place.
People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.
Crash Reporting - the action that caused the error, and the current state
There are plenty of options, the simplest is redux-thunk. But more advanced will be redux-saga or redux-observable.

 //redux-logger - It logs every actions , the state before and after that action

beauty of this redux pattern is how well it scales to large and complex apps 


//  redux store vs react state
1. One big state -> Redux store
2. Every component has its own state - this is react
3. Component state is manipulated using the this.setState -> only when we need minimal changes in that component itself
4. Redux state/ store is updated by actions using store.updateState();

//using REDUX store
1)data used across components
2)any data which is static and specific to component( bcoz static data can’t be used as state of the component)
3)fetch calls inside action which  fetches data and updates store. Now since store is connected to component data is passed through props.
Pick the data from props and  display it or do the error validation.

// Data updation via store
1)create key value pair in store 
2)create action to update the store 
3)call the action in the component lifecycle
4)connect component with store
5)pick the props from store and use it in the component 

//dealing with images or files
Arraybuffer is an array of raw binary data. It can only be accessed by using blob type.
Use FileReader to read that file (create a url mapping to that file)and load it into the page and/or localStorage using the url read.

//source map
Source map is used for debugging transpiled/minified files in production or transpiled files in development.
Source map is a json file (filename.js.map)which is generated using build and other tools like web pack etc which contains info of  what all files are transpiled/minified in to one.
sorucemappingurl directive is added by web pack at the end of minified/transpiled file with the info of original files.
On opening dev tools if source maps option is enabled in the browser settings then browser will look for sourcemappingurl in the minified file
And based on that it will fetch/download the corresponding original files which can be used for debugging.
If it is a secure site like banking or u want to protect the code from others use fiddler.

//go through all these links
https://serverless-stack.com/chapters/code-splitting-in-create-react-app.html
https://medium.freecodecamp.org/beginners-guide-to-react-router-4-8959ceb3ad58
https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95
https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d
https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/


//NODE JS - running js outside browser environment
built on the Chrome JavaScript runtime 
event-driven, non-blocking I/O model that makes it lightweight and efficient
perfect for data-intensive real-time applications that run across distributed devices
Node.js frameworks -  express, sails
Asynchronous	- code that not running at same time or with same speed
Package - bunch of modules
Socket.io is  web socket library 

//Webpack - runs on node , internally builds a dependency graph of modules
Used in modular programming environment like import and require. 
Loaders - tell webpack how to process non-js modules as webpack only understands JavaScript and JSON files.
via loaders It supports  modules written in a variety of languages and preprocessors like  typescript, coffee script, sass , less etc
Since version 4.0.0, webpack does not require a configuration file
plugins - perform tasks like bundle optimization, asset management and injection of environment variables.
TreeShaking - remove unused imports from bundle
HotModuleReplacement - update the modules.without a full refresh

