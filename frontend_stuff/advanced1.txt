//ADVANCED1 
//REACT IMP questions 
why react: declarative(we simply declare what we need and react takes care of implementation), component based, composition(component inside a component)
opp of declarative is imperative 
use: view library mostly used for developing SPAs 
presentational components are concerned with the look
container components are concerned with making things work
features: 
virtual dom(use diffing algorithm to push only the changes to real dom)
Unidirectional data flow - from parent to child
HOC(separate logic from UI)
Supports server-side rendering
JavaScript XML - syntactic sugar for the React.createElement()
four different phases of component lifecycle:
1)Initialization: setting up the initial state and default props
2)Mounting: 
constructor() - initialize state and bind methods
static getDerivedStateFromProps() -It should return an object to update the state, or null to update nothing.
componentWillMount() - unsafe bcoz there is no guarantee that react will call it only once.react can call this method multiple times
render() - only required method in a class component
componentDidMount() -  AJAX requests,event listeners,subsriptions etc
3)Updating: change in state/ change in props/ forceupdate
static getDerivedStateFromProps - It should return an object to update the state, or null to update nothing.
shouldComponentUpdate(prevProps, prevState) - bydefault true, If you are sure that the component doesn't need to render after state or props are updated, you can return false 
PureComponent performs a shallow comparison of props and state | PureComponent+immutable.js for performance
componentWillUpdate() - unsafe bcoz there is no guarantee that react will call it only once.react can call this method multiple times
render() - should be pure,i.e no state updates inside render | renders the contents on virtual DOM
getSnapshotBeforeUpdate() - gets the snapshot of DOM before it is updated like capturing scroll position
componentDidUpdate(prevProps, prevState)
4)Unmounting: componentWillUnmount() - invalidating timers, canceling network requests, or cleaning up any subscriptions
**Error Handling - These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.
static getDerivedStateFromError() - This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state
componentDidCatch() - log information about which component threw the error
Error boundaries are React components that implement one or both the above methods
*setState() does not always immediately update the component. It may batch or defer the update
 this.setState({quantity: 2}) - This form of setState() is also asynchronous, and multiple calls during the same cycle may be batched together.
 If the next state depends on the current state, we recommend using the updater function form, instead:
 this.setState((state) => {
  return {quantity: state.quantity + 1};
});
*forceUpdate() will cause render() to be called on the component, skipping shouldComponentUpdate()
React will still only update the DOM if the markup changes.
*SyntheticEvent, a cross-browser wrapper around the browser’s native event.
SyntheticEvent object will be reused and all properties will be nullified after the event callback 
has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way(like using event object in settimeout)
for using in an asynchronous way, you should call event.persist()
*Fragments - use less memory by not creating an extra DOM node | adding extra divs in the middle of layouts can disturb the layout
*diffing algorithm - time complexity for comparisons - O(n) where n is the number of elements in the tree
diffing algorithm based on two assumptions:
1)Two elements of different types will produce different trees.
React first compares the two root elements:Whenever the root elements have different types, React 
will tear down the old tree and build the new tree from scratch.
if the type is same React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes
Recursing On Children: React just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference
2)The developer can hint at which child elements may be stable across different renders with a key prop.
using keys eliminate the need of re-rendering of the child elements and simply change their places


What's the problem with MVW frameworks? How redux solves the problem
https://blog.gisspan.com/2017/02/Redux-Vs-MVC,-Why-and-How.html
//Problem with MVC
 MVC becomes  a headache  when an application grows in size as it is difficult to  manage multiple controllers and models and their interactions -  REDUX solution centralised store and only single way of modifying it
We lose control of who changed the state of a controller and why they changed it -  REDUX solution using actions to modify state and as they are JS objects we can log them
In MVC we mutate the model hence No way to do undo (travel back in time) easily�- REDUX solution no mutation
When to consider the state or model is changed and how to build tools to help recognize the mutation - REDUX solution  dispatch  action and subscribe to changes

//REDUX - strict unidirectional data flow Architecture�for building complex and scalable Apps (caching, PWA, server state sync, offline support etc)
3 core principles
1.Single source of truth - The whole application state is stored in an object tree inside a single�store.  // react components have their own component state
2.State is read-only - The only way to change the state tree is to emit an�action, an object describing what happened.
Actions are the�only source of information for the store. You send them to the store using�store.dispatch()
To specify how the actions transform the state tree, you write pure�reducers.
Actions can be triggered by user interaction/events , network request and on routing
Reducers are just pure functions that take the previous state and an action, and return the next state without mutating the state
//Things you should never do inside a reducer:
 Mutate its arguments;
 Perform side effects like API calls and routing transitions; (where to do it??)
 Call non-pure functions, e.g. Date.now() or Math.random()
each reducer manages its own part of the global state. The state parameter is different for every reducer, and corresponds to the part of the state it manages.
actions are processed by reducers synchronously.
Store
// each reducer returns a object and all the objects are merged to form a big object called store
// In the application state object each key is the reducer function name (it can be different as well)and value is the partial state returned by a reducer function
// partial state can be any data type not necessarily object
//keep your state as normalized as possible, without any nesting . if there is a nesting involved use immutable.js for performance
//once u dispatch an action to the store all the reducers are called and  based on the action type one/multiple reducers changes the  application state
//subscribers are only notified only once per dispatch action. i.e when all the reducers are done changing the state of the application by a single action
//Redux�s store has one method called�dispatch�and it has another method to subscribe to state changes called�subscribe�. But we can use  view binding library like react-redux
�React-redux generates container components using connect function .These components are connected/subscribed to the Redux store.��
Technically, a container component is just a React component that uses�store.subscribe()�to read a part of the Redux state tree and supply props to a presentational component it renders
you could write the container components by hand using�store.subscribe(). We don't advise you to do this because React Redux makes many performance optimizations that are hard to do by hand.
We can use batch function  to ensure that multiple actions dispatched outside of React only result in a single render update
middleware - for async actions
Synchronous actions - when we dispatch action(object) the state gets updated immediately
async actions - when we dispatch action(function) the state gets updated after sometime
an action creator(called thunk) can return a function /promise instead of an action object and that function/promise  will get executed by the Redux Thunk middleware. 
This function doesn't need to be pure. It is allowed to have side effects, including executing asynchronous API calls/routing etc. The function can also dispatch actions
Any middleware you use can then intercept anything you dispatch, and in turn, can pass actions to the next middleware in the chain. 
When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the�synchronous Redux data flow�takes place.
People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.
Crash Reporting - the action that caused the error, and the current state
There are plenty of options, the simplest is�redux-thunk. But more advanced will be�redux-saga�or�redux-observable.

�//redux-logger - It logs every actions , the state before and after that action

beauty of this redux pattern is how well it scales to large and complex apps 


//  redux store vs react state
1. One big state -> Redux store
2. Every component has its own state - this is react
3. Component state is manipulated using the this.setState -> only when we need minimal changes in that component itself
4. Redux state/ store is updated by actions using store.updateState();

//using REDUX store
1)data used across components
2)any data which is static and specific to component( bcoz static data can�t be used as state of the component)
3)fetch calls inside action which  fetches data and updates store. Now since store is connected to component data is passed through props.
Pick the data from props and  display it or do the error validation.

// Data updation via store
1)create key value pair in store 
2)create action to update the store 
3)call the action in the component lifecycle
4)connect component with store
5)pick the props from store and use it in the component 

//dealing with images or files
Arraybuffer is an array of raw binary data. It can only be accessed by using blob type.
Use FileReader to read that file (create a url mapping to that file)and load it into the page and/or localStorage using the url read.

//source map
Source map is used for debugging transpiled/minified files in production or transpiled files in development.
Source map is a json file (filename.js.map)which is generated using build and other tools like web pack etc which contains info of  what all files are transpiled/minified in to one.
sorucemappingurl directive is added by web pack at the end of minified/transpiled file with the info of original files.
On opening dev tools if source maps option is enabled in the browser settings then browser will look for sourcemappingurl in the minified file
And based on that it will fetch/download the corresponding original files which can be used for debugging.
If it is a secure site like banking or u want to protect the code from others use fiddler.

//go through all these links
https://serverless-stack.com/chapters/code-splitting-in-create-react-app.html
https://medium.freecodecamp.org/beginners-guide-to-react-router-4-8959ceb3ad58
https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95
https://medium.com/@baphemot/understanding-reactjs-component-life-cycle-823a640b3e8d
https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/


//NODE JS - running js outside browser environment
built on the Chrome JavaScript runtime�
event-driven, non-blocking I/O model that makes it lightweight and efficient
perfect for data-intensive real-time applications that run across distributed devices
Node.js frameworks -  express, sails
Asynchronous	- code that not running at same time or with same speed
Package - bunch of modules
Socket.io is  web socket library 

//Webpack - runs on node , internally builds a dependency graph of modules
Used in modular programming environment like import and require. 
used for complex JavaScript applications for bundling JavaScript modules  also with lots of non-code assets (images, fonts, CSS, etc.)
Loaders - tell webpack how to process non-js modules as webpack only understands JavaScript and JSON files.
via loaders It supports  modules written in a variety of languages and preprocessors like  typescript, coffee script, sass , less etc
most imp loaders: url-loader, html-loader, file-loader(image handling), style-loader, css-loader, eslint-loader, babel-loader, loaders for typescript, coffescript, less, sass
*babel(convert es6 and higher version code to es5 for backward compatability to run on older browsers, JSX and typescript code to js )
browserify is only used to resolve dependencies
Since version 4.0.0,�webpack does not require a configuration file
plugins - used to customize webpack’s build process(like minify js, minify css, remove comments)
perform tasks like , asset management and injection of environment variables.
imp plugins: (HtmlWebpackPlugin)Generates an `index.html` file with the <script> injected, CompressionWebpackPlugin(serve the compressed assets) and 
ExtractTextWebpackPlugin(we can extract all the css code and put into one css file and not he bundle.js)
 If your total stylesheet volume is big, it will be faster because the CSS bundle is loaded in parallel to the JS bundle.
loaders are not able to influence the actual build process.
A webpack plugin is a JavaScript object that has an apply property. This apply property is called by the webpack compiler, giving access to the entire compilation lifecycle.
access (and modify) the compiler, and how it works, as well as the compilation. Therefore, they are more powerful, but also harder to maintain.
*TreeShaking - remove unused imports from bundle
*HotModuleReplacement - update the modules without a full refresh (advancement over live refresh)
*grunt and gulp are task runners which are used to automate the tasks like(minification,linting,compiling sass,typescript) 
webpack is a module bundler (it is a  superset which also performs the tasks of a task runner)
*grunt and gulp look into a defined path for files that match your configuration, while the Webpack analyzes the whole project
hence it is used with projects that are highly scalable
*bundle is the output file generated by webpack
*starting from the entry point webpack recursively builds a dependency graph that includes every module your application needs then packages all of those modules into bundle(s)
*require vs import - time and memory advantage with import
require - dynamic and conditional loading | Loading is synchronous. That means if you have multiple requires, they are loaded and processed one by one.
import - use named imports to selectively load only the pieces you need. That can save memory | asynchronous loading
*multiple entry points - to speed up the build process by creating multiple builds in parallel
*chunks - vendor dependencies(node modules) in one chunk, all the common modules in one chunk to eliminate duplicacy(using SplitChunksPlugin)
and code splitting in other chunks
[hash] will generate unique hash for each build and use it for all chunks. 
Replace [hash] with [chunkhash] to generate unique hashes for each chunk. 
This is useful when you dont want to re-download vendors (dependencies) file but you have changes in your application code and want to update it.
//code-splitting and lazy-loading
code-splitting  - breaking (or splitting) your app into various parts so your entire app does not need to load straight away.
if dynamic import tag is seen by webpack it spilts the code in small chunks and loads it on demand
preload and prefetch - load the chunks without user interaction
lazy-loading - load the chunk only when user performs an action
A preloaded chunk(medium priority) starts loading in parallel to the parent chunk (instead of 2 round trips now there is only one)
as size of parent chunk is small it boosts initial load time
import(/* webpackPreload: true */ 'ChartingLibrary');
A prefetched chunk(low priority) starts after the parent chunk finishes loading and when the browser is idle.
import(/* webpackPrefetch: true */ 'LoginModal');
This will result in <link rel="prefetch" href="login-modal-chunk.js"> being appended in the head of the page, which will instruct the browser to prefetch in idle time

//lazy rendering - intersection observer API by browser
clientsboundrect(to get the element position wrt viewport) + debounce/throttle the scroll event

** code splitting using lazy(dynamic import of components) and suspense(fallback to show when components are downloaded)
//https://medium.com/@rossbulat/react-lazy-suspense-and-concorrent-react-breakdown-with-examples-2758de98cb1c