//terminologies
**scalability - handling huge number of requests
1)vertical scalability - increase the current system's computation power, memory, RAM 
time taken to process a request is reduced
single point of failure
inter process communication as there is only server
data consistency
2)horizontal scalability - increase the total number of servers
load balancer is needed
if one of the server fails there are other servers to bank on
network communication b/w servers


//approach


//design whatsapp


//design twiter

//building large applications that can scale
1)client side
web performance - loading + rendering performance
react


2)server side
microservice - decoupling
CDN - caching, reduce latency 
caching - eviction policy needs to be good like LRU and it should have large size else extra call to cache, 
cache invalidation
background sync - update ur cache first and then after every 10sec sync ur updated cache with db in a single request
but keep a list of updated keys so that after 10sec u go and update the data corresponding to keys in ur db
load balancing - distribute load between servers (round robin, weighted round robin, least connections,
weighed least connections, URL Hash and least latency), consistent hashing
Least latency - makes a quick HTTP OPTIONS request to backend servers, and sends the request to the first server to answer
//Consistent hashing assigns requests to the servers in a way that the load is equally balanced on servers
Consistent Hashing maps servers to the key space and assigns requests to the next clockwise server
M hash fns and N servers - servers are placed at N*M points
2 principles allowed by Consistent Hashing - fault tolerance(removing servers), scalability (adding servers)
cloud - large computing 
kafka - messaging queue 
polling - using background thread for making request after every x sec to get new data like feed/ 
to tell if a person is online or not 
long polling - make a request and keep connection open until new data comes 
polling and long polling are used as backward compatibility to web sockets 
websockets - like http it is a communication protocol | considered as a upgradation to http protocol
used make a TCP connection once and then bidirectional communication between client and server on the same TCP connection
used in real time data transfer applications like chat/trading/online gaming 
**how browser establishes web socket connection?
WebSocket "is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries," thus making it compatible with the HTTP protocol.
client sends a WebSocket handshake request, for which the server returns a WebSocket handshake response
Once the connection is established, communication switches to a bidirectional binary protocol which does not conform to the HTTP protocol.
WebSocket transmissions are described as "messages", where a single message can optionally be split across several data frames. 
WebSocket requests are not restricted by the Same-origin policy. Therefore WebSocket servers must validate the "Origin" header against the expected origins during connection establishment,
 to avoid Cross-Site WebSocket Hijacking attacks 
It is better to use tokens or similar protection mechanisms to authenticate the WebSocket connection when sensitive (private) data is being transferred 
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
Server response:

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat

**socket.io - js library for web sockets (just like jquery is to javascript)
handles fallback(if client and server doesn't agree on handshake then uses long polling as a 
fallback mechanism to support old browsers) and auto-reconnection
fan-in : all the client requests coming to a server
fan-out: requests going from server to clients
problem with fan-out is if million users are to be notified then server gets crashed
so use rate limiting (1000 requests/sec etc)
*SSE - server sent events - client initiates the SSE connection using EventSource API (server uses event source protocol)
The client canâ€™t send any data to the server after the initial handshake.
EventSource instance opens a persistent connection to an HTTP server, which sends events in text/event-stream format. The connection remains open until closed by calling EventSource.close().
Examples: Facebook/Twitter updates, stock price updates, news feeds, sport results or delivering 
data into a client-side storage mechanism like IndexedDB or web storage etc where a user interaction is not needed

const sse = new EventSource('/api/v1/sse');
  
  based on the type of events sent by the server we can listen to those specific events 
  /* This will listen only for events with event type notice */
 
  sse.addEventListener("notice", function(e) { 
    console.log(e.data)
  })

  /* Similarly, this will listen for events  with the field `event: update` */
  sse.addEventListener("update", function(e) {
    console.log(e.data)
  })

  sse.addEventListener("message", function(e) {
    console.log(e.data)
  })


3)databases
sharding - split ur database - useful for microservice architecture
vertical sharding - put each table in a new machine so that the requests get split
machine1 - user profile requests will go to this machine
machine2 - user cart table requests will go to this machine
horizontal sharding - split a single table and put it into multiple machines (based on time/userid/geography)
machine1 - user profile table(indian profile) - request from india will be routed to machine1
machine2 - user profile table(american profiles) - request from america will be routed to machine2
apply indexing on a horizontally sharded table
//To reduce load on main db server
1)in memory caching - reddis, memcache
2)master-slave architecture
all read operations from slaves
all write operations to master and sync master with slaves

whatsapp - https://www.youtube.com/watch?v=vvhC64hQZMk
parking lot - https://www.youtube.com/watch?v=DSGsa0pu8-k
uber - https://www.youtube.com/watch?v=umWABit-wbk
