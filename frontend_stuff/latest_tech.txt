//GraphQL - A query language for your API
GraphQL has three main characteristics:
It lets the client specify exactly what data it needs.
It makes it easier to aggregate data from multiple sources.
It uses a type system to describe data.

*GraphQL on the other hand is like having a personal assistant: 
In other words, GraphQL establishes a standard language for talking to this magical personal assistant.
*GraphQL API is organized around three main building blocks: the schema, queries, and resolvers.
Queries - The request you make to your GraphQL personal assistant is the query
Resolver - tells GraphQL how and where to fetch the data corresponding to a given field.

*While typical REST APIs require loading from multiple URLs, GraphQL APIs get all the data your app needs in a single request. 
Apps using GraphQL can be quick even on slow mobile network connections.

//REACT(library) VS ANGULAR(framework-MVC archiecture) VS VUE
REACT - virtual DOM
Built for large and complex web apps 
HTML ,CSS and JS all clubbed in to one component
Virtual DOM - only updating parts of the DOM that changed instead of rendering the whole DOM
React hooks lets you use every important feature of React � server-side rendering, accessibility, concurrent mode, and suspense � all without writing a class.
React doesn't deep compare and hence never mutate state or props | Immutable data cannot be changed once created
https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56
VUE - 
Easy to learn, lightweight, integration in the existing	projects, excellent documentation, virtual DOM, security, separation of HTML,CSS and JS
ideal for startups and can also be used for large web apps
Vue has official packages for state management, routing, or server-side rendering. unlike React where u are free to use anything
1)Angular - Everything is available inbuilt. In react u can choose from many options(flexibility)
2)two-way data binding(data mutable) vs unidirecional flow(immutable data)
3)REACT(library) VS ANGULAR(framework)
4)REACT(virtual DOM) VS ANGULAR(real DOM)
5)React requires a set of tools to perform different types of testing.
The testing and debugging for a complete angular project is possible with a single tool.
**both are component based and used for creating SPAs/MPAs

//mongodb vs sql
*SQL requires that you use predefined schemas to determine the structure of your data before you work with it. In addition, all of your data must follow the same structure
*NoSQL databases, on the other hand, have dynamic schemas for unstructured data, and data is stored in many ways: They can be column-oriented, 
document-oriented, graph-based or organized as a KeyValue store. 
**scalability
In most situations, SQL databases are vertically scalable, which means that you can increase the load on a single server by increasing things like 
CPU, RAM or SSD. NoSQL databases, on the other hand, are horizontally scalable. This means that you handle more traffic by sharding, 
or adding more servers in your NoSQL database.
*The Structure
SQL databases are table-based, while NoSQL databases are either document-based, key-value pairs, graph databases or wide-column stores.
*Some examples 
SQL databases include MySQL, Oracle, PostgreSQL, and Microsoft SQL Server. 
NoSQL database examples include MongoDB, BigTable, Redis, RavenDB Cassandra and CouchDB


//java vs node
*Node.js is NOT a programming language. It is also not a framework. Node.js is an open-source, cross-platform JavaScript (JS) run-time environment that executes JavaScript code outside of a browser
*Node is for simple, fast and scalable and real-time applications. Java is for highly complex and concurrent apps.
*Node for I/O-intensive apps that include a lot of disk or network access, therefore we can serve more clients, without the need of throwing more hardware.
 And that is why Node applications are highly scalable.
*Node shouldn�t be used for CPU-intensive applications (video encoding, image manipulation service etc.) as it is single threaded (worker threads can help)
*Java is platform independent due to the so-called Java Virtual Machine � the environment where Java code is executed.
Node.js has modules that are tied to the operating system. When you need the software to run on another platform, you will have to rebuild the modules, so that they are compatible with the new OS.

//monolithic vs Microservices
*Microservices are frequently deployed on their own virtual machines - loosely coupled(independent of other services)
parallel development - each service has its own database - can be reused in other projects
scalable - e.g u have profile, analytics and chat service in ur system. if people are using more of
the chat service then we can scale(horizontally scalaing) i.e add more chat servers
A monolithic architecture - app is written as one cohesive unit of code - tighly coupled,
sharing the same memory space and resources - frequent deployments - rigrous testing
if something fails enire system fails

//in-memory database - fast manipulaion, updation
An in-memory database(Redis) is a database management system that primarily relies on main memory for 
computer data storage. It is contrasted with database management systems that employ a disk storage mechanism

//database sharding
partitioning db based on location/timestamp etc so that the lookup is fast
on top of it apply indexing so that u can use binary search and reduce the time even further

//CDN vs Cloud computing
**CDN is simply a network of servers that replicate your binary files so that they are served from geographically close locations. 
CDN has been around for a lot longer than cloud computing as you know it today.
Not every cloud provider is a CDN, and not every CDN is a cloud computing provider.
**Cloud computing is simply - dividing up a large computing resource (usually processing power) into little chunks which you can use remotely.


//WebAssembly
https://blog.logrocket.com/webassembly-how-and-why-559b7f96cd71/
This enables the use of pre-compiled executables for performance-critical portions of page scripts.
for e.g: achieving performance of a native video games and audio application in the browser is hard 
that is where web assembly pitches in.
You do not write WebAssembly, you compile other higher level languages like C, C++ or Rust code and 
compile it into what is called a WebAssembly module. 
You can load that into your web application and call it from JavaScript. It runs in the same sandbox 
as regular JavaScript code (It’s not a replacement for JavaScript, it works alongside JavaScript)
JavaScript - parse(abstract syntax tree), compile and optimize it
WASM - decode and compile because Most of the optimization happens during the compilation of source code, before it even gets into the browser.
With WebAssembly there is only one compilation step and your app will run in every modern browser.
Until now, JavaScript has been the only fully supported language in web browsers. With WebAssembly, web developers will be able to choose other
languages and more developers will be able to write code for the web.
You can call WebAssembly functions in JavaScript code and you can call JavaScript functions in WebAssembly modules.


//web components - suite of different technologies allowing you to create reusable custom elements 
web components are imperative(u explicitly iterate on DOM) but react components are declarative
you are free to use React in your Web Components, or to use Web Components in React


//distributed file system vs local file system (storing images, audio, videos,docs etc)
*client feels that big file that is uploaded is handled by one system but internally that individual
file is being split into blocks and stored in multiple systems
*processing speed is high and time is low since multiple systems are handling the single file
*data replication(atleast 3 replicas) and failure tolerance are taken care by the DFS but 
if u store files in local file system u explicitly need to handle this
*There is a max limit for increasing capacity of a single system
