//Webpack - runs on node , internally builds a dependency graph of modules
Used in modular programming environment like import and require. 
used for complex JavaScript applications for bundling JavaScript modules  also with lots of non-code assets (images, fonts, CSS, etc.)
Loaders - tell webpack how to process non-js modules as webpack only understands JavaScript and JSON files.
via loaders It supports  modules written in a variety of languages and preprocessors like  typescript, coffee script, sass , less etc
most imp loaders: url-loader, html-loader, file-loader(image handling), style-loader, css-loader, eslint-loader, babel-loader, loaders for typescript, coffescript, less, sass
*babel(convert es6 and higher version code to es5 for backward compatability to run on older browsers, JSX and typescript code to js )
browserify is only used to resolve dependencies
Since version 4.0.0,�webpack does not require a configuration file
plugins - used to customize webpack’s build process(like minify js, minify css, remove comments)
perform tasks like , asset management and injection of environment variables.
imp plugins: (HtmlWebpackPlugin)Generates an `index.html` file with the <script> injected, CompressionWebpackPlugin(serve the compressed assets) and 
ExtractTextWebpackPlugin(we can extract all the css code and put into one css file and not he bundle.js)
 If your total stylesheet volume is big, it will be faster because the CSS bundle is loaded in parallel to the JS bundle.
loaders are not able to influence the actual build process.
A webpack plugin is a JavaScript object that has an apply property. This apply property is called by the webpack compiler, giving access to the entire compilation lifecycle.
access (and modify) the compiler, and how it works, as well as the compilation. Therefore, they are more powerful, but also harder to maintain.
*TreeShaking - remove unused imports from bundle
*HotModuleReplacement - update the modules without a full refresh (advancement over live refresh)
*grunt and gulp are task runners which are used to automate the tasks like(minification,linting,compiling sass,typescript) 
webpack is a module bundler (it is a superset which also performs the tasks of a task runner)
*grunt and gulp look into a defined path for files that match your configuration, while the Webpack analyzes the whole project
hence it is used with projects that are highly scalable
*bundle is the output file generated by webpack
*starting from the entry point webpack recursively builds a dependency graph that includes every module your application needs then packages all of those modules into bundle(s)
*require vs import - time and memory advantage with import
require - dynamic(module names resolved at run time) and conditional loading | Loading is synchronous.
That means if you have multiple requires, they are loaded and processed one by one.
import - use named imports to selectively load only the pieces you need. That can save memory | asynchronous loading
*multiple entry points - to speed up the build process by creating multiple builds in parallel
*chunks - vendor dependencies(node modules) in one chunk, all the common modules in one chunk to eliminate duplicacy(using SplitChunksPlugin)
and code splitting in other chunks
[hash] will generate unique hash for each build and use it for all chunks. 
Replace [hash] with [chunkhash] to generate unique hashes for each chunk. 
This is useful when you dont want to re-download vendors (dependencies) file but you have changes in your application code and want to update it.
//code-splitting and lazy-loading
code-splitting  - breaking (or splitting) your app into various parts so your entire app does not need to load straight away.
if dynamic import tag is seen by webpack it spilts the code in small chunks and loads it on demand
preload and prefetch - load the chunks without user interaction
lazy-loading - load the chunk only when user performs an action
A preloaded chunk(medium priority) starts loading in parallel to the parent chunk (instead of 2 round trips now there is only one)
as size of parent chunk is small it boosts initial load time
import(/* webpackPreload: true */ 'ChartingLibrary');
A prefetched chunk(low priority) starts after the parent chunk finishes loading and when the browser is idle.
import(/* webpackPrefetch: true */ 'LoginModal');
This will result in <link rel="prefetch" href="login-modal-chunk.js"> being appended in the head of the page, which will instruct the browser to prefetch in idle time

//lazy rendering - intersection observer API by browser
clientsboundrect(to get the element position wrt viewport) + debounce/throttle the scroll event

** code splitting using lazy(dynamic import of components) and suspense(fallback to show when components are downloaded)
//https://medium.com/@rossbulat/react-lazy-suspense-and-concorrent-react-breakdown-with-examples-2758de98cb1c