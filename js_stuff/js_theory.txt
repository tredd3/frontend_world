//js engines
first JavaScript engines were mere interpreters, but all relevant modern engines utilize just-in-time compilation for improved performance
The use of JavaScript engines is not limited to browsers. For example, the Chrome V8 engine is a core component of the popular Node.js runtime system
firefox - mozilla - spider monkey(netscape navigator)
google - chrome - V8
apple - safari - nitro
microsoft - IE -  chakra | edge - V8
Browsers have added support for WebAssembly - 4th language browsers can understand apart from html,css and js
layout engine or rendering engine: ransform HTML and css to a visual representation
gecko - mozilla
webkit - apple
chrome - blink
edge - blink


//functional programming
1)Pure functions instead of shared state & side effects : optimizations by compiler
/gives same output for same arguments all the times (This can enable caching optimizations such as memoization)
/A function is said to have a side effect if it modifies some state variable value(s) outside its local environment.
/Example side effects include modifying a non-local variable, modifying a static local variable, 
modifying a mutable argument passed by reference, performing I/O or calling other side-effect functions.
/If there is no data dependency between two pure expressions, their order can be reversed, or they can be performed in parallel 
2)Function composition
3)Immutability is a central concept of functional programming
An immutable object is an object that can’t be modified after it’s created
4)FP concepts - HOC(for reusability instead of polymorphism), function composition(instead of inheritance)
closures instead of encapsulation, currying
Higher-order functions are functions that can either take other functions as arguments or return them as results
5)Declarative rather than imperative code (what to do, rather than how to do it)
6)In functional programming things are loosely coupled but in OO things are tightly coupled.

Traditional Imperative Loop:

const numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
let result = 0;
for (let i = 0; i < numList.length; i++) {
  if (numList[i] % 2 === 0) {
    result += (numList[i] * 10)
  }
}
Functional Programming with higher-order functions:

const numList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const result = numList
               .filter(n => n % 2 === 0)
               .map(a => a * 10)
               .reduce((a, b) => a + b)


//javascript imp stuff
*JavaScript is a high-level, dynamic, untyped, and interpreted programming language.
*examples of low-level languages are assembly and machine code -  machine-dependent and non-portable - It needs assembler for translation
*high level languages are C, C++, Java, Python,js - needs compiler or interpreter for translation
*JavaScript is a multi-paradigm language, supporting functional and object oriented (prototypal inheritance) - 2 pillars of js
*First-class functions - function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable
*FP - avoids shared state & mutable data, first-class functions, higher order functions, function composition, Pure functions,Avoid side-effects
*OOP - tightly coupled, shared state, different things competing for the same resources(race condition)

//currying - functional programming concept is the idea of currying or partially applying argument values to a function
//currying - splitting up a function that takes multiple arguments (params) into a sequence of functions that each take an individual argument.
const sum = function(a) {
  return function(b) {
    return a + b
  }
}
sum(3)(4)
// no curry
const sum = (a, b) => a + b

// curry
const sum = a => b => a + b

By currying and composing your functions u r creating a pipeline for data processing.

//This in js - call, apply and bind to the rescue
As a DOM event handler - set to the element on which the listener is placed //this === e.currentTarget
As a constructor - this is bound to the new object being constructed.
object method - this is set to the object the method is called on.
arrow function - this is permanently bound to the this of its enclosing function.
global execution context (outside of any function), this refers to the global object whether in strict mode or not.
random function - this refers to window and undefined in strict mode
function f2() {
  'use strict'; // see strict mode
  return this;
}
f2() === undefined; // true

var o = {
  prop: 37,
  f: function() {
    return this.prop;
  }
};
console.log(o.f()); // 37

var o = {prop: 37};
function independent() {
  return this.prop;
}
o.f = independent;
console.log(o.f()); // 37

var o = {f: function() { return this.a + this.b; }};
var p = Object.create(o);
p.a = 1;
p.b = 4;

console.log(p.f()); // 5

var obj = {
  bar: function() {
    var x = (() => this);
    return x;
  }
};
var fn = obj.bar();
console.log(fn() === obj); // true
var fn2 = obj.bar;
console.log(fn2()() == window); 

function f() {
  return this.a;
}
var g = f.bind({a: 'azerty'});
console.log(g()); // azerty
var h = g.bind({a: 'yoo'}); // bind only works once!
console.log(h()); // azerty