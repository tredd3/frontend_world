
//Factory Functions vs Constructor Functions vs Classes
In JavaScript, any function can return a new object. When it�s not a constructor function or class, it�s called a factory function.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model

*A prototype-based language has the notion of a prototypical object, an object used as a template from which to get the initial properties for a new object.
 Any object can specify its own properties, either when you create it or at run time. In addition, any object can be associated as the prototype for
 another object, allowing the second object to share the first object's properties

*JS is a object based language and not a class based language.
ES6 classes are primarily syntactical sugar over JavaScript's existing prototype-based inheritance.
The class syntax does not introduce a new object-oriented inheritance model to JavaScript.
new operator in association with the constructor method to create class instance / new operator with a constructor function to create a new object.
var Jane = new Engineer('Doe, Jane'); //Jane is a pointer to the new object created
The new operator creates a generic object and sets its __proto__ property to Engineer.prototype.
The new operator passes the new object to the Engineer constructor as the value of the this keyword.


*In class-based languages, you typically create a class at compile time and then you instantiate instances of the class either at compile time 
or at run time. You cannot change the number or the type of properties of a class after you define the class.
In JavaScript, however, at run time you can add or remove properties of any object // dynamic inheritance is possible

*The instanceof operator tests whether the prototype property of a constructor appears anywhere in the prototype chain of an object.
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
var mycar = new Car('Honda', 'Accord', 1998);
var a = mycar instanceof Car;    // returns true
var b = mycar instanceof Object; // returns true

*Some object-oriented languages allow multiple inheritance. That is, an object can inherit the properties and values from unrelated parent objects. 
JavaScript does not support multiple inheritance.
However in a constructor function we can call multiple constructor functions but ONLY one constructor prototype chain can be linked to __proto__
function MyClass() {
  SuperClass.call(this);
  OtherSuperClass.call(this);
}

// inherit one class
MyClass.prototype = Object.create(SuperClass.prototype);
// mixin another
Object.assign(MyClass.prototype, OtherSuperClass.prototype);
// re-assign constructor
MyClass.prototype.constructor = MyClass;


*Boilerplate code - sections of code that have to be included in many places with little or no alteration

//databases are best for data and the file system(storage/hard disk) is best for files.
some pros and cons involved in saving the files in the file system and database.
//Pros of the File system:
*Saving the files and downloading them in the file system is much simpler than database since a simple Save as function will help you out. 
Downloading can be done by addressing an URL with the location of the saved file.
*Migrating the data is an easy process here. You can just copy and paste the folder to your desired destination 
*Easy to migrate it to Cloud storage like Amazon S3 or CDNs etc in the future.
//Cons of the File system: security | hackers can hack into ur system and delete/edit the files but that can be overcome by choosing proper folder structure and permissions
//When is it most preferred: Large files of size more than 5MB and the massive number say thousands of file uploads.   

//Pros of Database: rollback of an update , More Secure than saving in a File System
//Cons of Database: You may have to convert the files to blob in order to store it in db , large files make db heavy, if so many users are accessing 
the same image then we Should not store  it in db.
If you're storing images for a web page then it's best to store them as a file on the server. The web server will very quickly find an image file and
send it to a visitor. Sending files to visitors is the main job of a web server.
If you were to store the same image in a database then the amount of steps to get to this image is greatly increased so the image will be slower 
to download. Also it will use up more server resources. The web server will have to connect to the database and then query the database to get the 
image, download the image from the database and then send the visitor the image
//When is it most preferred:security of the file is the utmost concern like Aadhar, If your application will not demand a large number of files from a large number of users.

//BLOB(binary large object) - collection of binary data stored as a single entity in a database management systems (DBMS). BLOBs are used primarily to hold 
multimedia objects such as images, videos, and sound, though they can also be used to store programs or even fragments of code
//DB indexing : Indexing is a way of sorting a number of records on multiple fields. Creating an index on a field in a table creates another data structure 
which holds the field value, and a pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be 
performed on it.


//error handling
class ValidationError extends Error {
  constructor(message) {
    super(message)
    this.name = 'ValidationError'
    this.message = message
  }
}
class PermissionError extends Error {
  constructor(message) {
    super(message)
    this.name = 'PermissionError'
    this.message = message
  }
}
class DatabaseError extends Error {
  constructor(message) {
    super(message)
    this.name = 'DatabaseError'
    this.message = message
  }
}

const { ValidationError } = require('./error')
function myFunction(input) {
   if (!input)
     throw new ValidationError('A validation error')
   return input
}

//iteration in JS
https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript.html
*For, foreach and for/in looping constructs give you access to the index in the array and actual element 
*for of only gives access to element and not index | for (const [i, v] of arr.entries()) { console.log(i, v); // Prints "0 a", "1 b", "2 c" }
*for, for/in, and for/of retain the outside scope's value of this, but the forEach() callback will have a different this unless you use an arrow function.
*Avoid using for/in over an array unless you're certain you mean to iterate over non-numeric keys and inherited keys
*forEach() and for/in skip empty elements in the array, for and for/of do not
*you can't use await and yield within a forEach()


//Math methods
console.log(Math.trunc(13.37)); // expected output: 13
var x=13.37 | x.toFixed() //13
Math.pow(x,y)
Math.max(a,b,c,d,.......)
var arr = [1, 2, 3];
Math.max(...arr);
Math.max.apply(null, arr);
var max = arr.reduce(function(a, b) {
    return Math.max(a, b);
});
Math.min(a,b,c,d,.......)
Math.floor( 45.05); //  45
Math.floor(-45.05); // -46 
Math.ceil(7.004);  // 8
Math.ceil(-7.004); // -7
Math.hypot([x[, y[, …]]]) - Returns the square root of the sum of squares of its arguments
Math.random() // random number between 0 (inclusive) and 1 (exclusive)
Math.random() * (max - min) + min // random number between 0 (inclusive) and 1 (exclusive)
Math.round() - returns the value of a number rounded to the nearest integer.
Math.round( 20.3); //  20
Math.round( 20.6); //  21